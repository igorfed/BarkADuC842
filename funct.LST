C51 COMPILER V6.12  FUNCT                                                                  07/20/2015 16:37:40 PAGE 1   


C51 COMPILER V6.12, COMPILATION OF MODULE FUNCT
OBJECT MODULE PLACED IN .\funct.OBJ
COMPILER INVOKED BY: e:\Keil\C51\BIN\C51.EXE .\funct.c OPTIMIZE(9,SPEED) REGFILE(.\bark.ORC) DEBUG OBJECTEXTEND

stmt level    source

   1          /*
   2          ; Bark v. 3.01
   3          ; Процессор:	ADuC 824
   4          ; Компилятор:	Keil C51
   5          ; Автор:	K. Rogatchev
   6          ; Работа с гистограммой.
   7          ;_________________________________________________________________________________________________*/
   8          #include <ADI\ADUC824.H>
   9          #include <stdio.h>
  10          #include <ctype.h>
  11          #include <absacc.h>
  12          
  13          #include "uart.h"
  14          #include "bark.h"
  15          
  16          //extern char code s_sum[];
  17          //extern struct st_thres data thres;
  18          extern unsigned char data average;
  19          extern unsigned char data thres_right;
  20          extern char num_ch;
  21          extern unsigned char MemDefine;
  22          unsigned short sum = 0;
  23          unsigned long lsum = 0L;
  24          unsigned long l_sum = 0L;
  25          //unsigned long lhistsum = 0L;
  26          
  27          void fTimer(unsigned char , unsigned char );
  28          
  29          void DelayStopMotor(unsigned long );
  30          
  31          void CalcHistSum( void )
  32          {
  33   1      	unsigned char i;
  34   1      	char byte[2];
  35   1      
  36   1      	sum = 0;
  37   1      	lsum = 0L;
  38   1      	l_sum = 0L;
  39   1      	EX0 = 0; // disable interrupt from RS-485
  40   1      	XBYTE[MEM_DEFINE] = MEM_HIST;	
  41   1      	MemDefine = MEM_HIST;			/* save the current value of MEM_DEFINE */
  42   1      	XBYTE[MEM_ADDR] = 255;			
  43   1      	thres_right = 0;
  44   1      	i = 0;
  45   1      	do
  46   1      	{
  47   2      		byte[0] = XBYTE[MEM_DATA_H];
  48   2      		byte[1] = XBYTE[MEM_DATA_L];
  49   2      		sum = sum + *((unsigned short*)byte);
  50   2      		if( CY )	  //???
  51   2      		{
  52   3      			i--;
  53   3      			break;
  54   3      		}
  55   2      		i--;
C51 COMPILER V6.12  FUNCT                                                                  07/20/2015 16:37:40 PAGE 2   

  56   2      	} while( (i != 0) && (sum < QUANT_R) );
  57   1      		thres_right = i;
  58   1      		i = 0;
  59   1      		if( sum == 0xFFFF )
  60   1      		{
  61   2      			do
  62   2      			{
  63   3      				byte[0] = XBYTE[MEM_DATA_H];
  64   3      				byte[1] = XBYTE[MEM_DATA_L];
  65   3      				lsum = lsum + (unsigned long)(*((unsigned short*)byte));
  66   3      			}
  67   2      			while( --i != 0 );
  68   2      		}
  69   1      		else
  70   1      		{
  71   2      			lsum = (unsigned long)sum;
  72   2      		}
  73   1      	EX0 = 1; // enable interrupt from RS-485
  74   1      }
  75          
  76          void CalcAverage( void )
  77          {
  78   1      
  79   1      	average = XBYTE[AVERAGE]; //reading 0x80FF address
  80   1      }
  81          
  82          bit SelfExamine( )
  83          {
  84   1      	char tmp, i;
  85   1      	bit stat = 1;
  86   1      
  87   1      	tmp = XBYTE[ FILTER ];
  88   1          putchar( '\n' );
  89   1          putchar( 'F' );putchar( 'i' );putchar( 'l' );putchar( 't' );putchar( 'e' );putchar( 'r' );putchar( 's'
             - );putchar( ' ' );putchar( 'S' );putchar( 't' );putchar( 'a' );putchar( 't' );putchar( 'e' );putchar( 's' );putchar( '='
             - );
  90   1          UartSendByte( tmp );
  91   1      	
  92   1      	if( tmp & 0x08  )
  93   1      	   {putchar( '\n' );
  94   2            putchar( 'M' );putchar( 'E' );putchar( '-' );putchar( '1' );putchar( '0' );putchar( '6' );putchar( '
             - ' );putchar( '(' );putchar( 'N' );putchar( 'F' );putchar( ')' );putchar( ' ' );putchar( 'F' );putchar( 'i' );putchar( '
             -l' );putchar( 't' );putchar( 'e' );putchar( 'r' );putchar( ' ' );putchar( 'o' );putchar( 'p' );putchar( 'e' );putchar( '
             -n' );
  95   2      	   }	
  96   1      	if( tmp & 0x20  )
  97   1      	   {putchar( '\n' );
  98   2            putchar( 'M' );putchar( 'E' );putchar( '-' );putchar( '1' );putchar( '0' );putchar( '5' );putchar( '
             - ' );putchar( '(' );putchar( 'M' );putchar( 'F' );putchar( ')' );putchar( ' ' );putchar( 'F' );putchar( 'i' );putchar( '
             -l' );putchar( 't' );putchar( 'e' );putchar( 'r' );putchar( ' ' );putchar( 'o' );putchar( 'p' );putchar( 'e' );putchar( '
             -n' );
  99   2      	   }	   
 100   1      	if( tmp & 0x02  )
 101   1      	   {putchar( '\n' );
 102   2           putchar( 'M' );putchar( 'E' );putchar( '-' );putchar( '1' );putchar( '0' );putchar( '4' );putchar( ' 
             -' );putchar( '(' );putchar( 'W' );putchar( 'F' );putchar( ')' );putchar( ' ' );putchar( 'F' );putchar( 'i' );putchar( 'l
             -' );putchar( 't' );putchar( 'e' );putchar( 'r' );putchar( ' ' );putchar( 'o' );putchar( 'p' );putchar( 'e' );putchar( 'n
             -' );	
 103   2      	   }
 104   1      
 105   1      	for( i = 0; i < 3; i++ )
 106   1      	{
C51 COMPILER V6.12  FUNCT                                                                  07/20/2015 16:37:40 PAGE 3   

 107   2      		XBYTE[ NUM_CHANNEL ] = i;
 108   2      		XBYTE[ FILTER ] = F_IN;
 109   2      	}
 110   1      
 111   1      	TIMECON = 0; // Time Clock disable
 112   1      	HTHSEC = 0;
 113   1      	SEC = 0;
 114   1      	TIMECON = 0x09; // Time Clock enable
 115   1      	while( SEC < 2 );
 116   1      	tmp = XBYTE[ FILTER ];
 117   1          putchar( '\n' );
 118   1          putchar( 'F' );putchar( 'i' );putchar( 'l' );putchar( 'e' );putchar( 'r' );putchar( 's' );putchar( ' '
             - );putchar( 'S' );putchar( 't' );putchar( 'a' );putchar( 't' );putchar( 'e' );putchar( 's' );putchar( '=' );
 119   1          UartSendByte( tmp );
 120   1      	if( tmp != 0x2A )
 121   1      	{
 122   2      		stat =  0;
 123   2      	}
 124   1      	
 125   1      	if( tmp & 0x08  )
 126   1      	   {putchar( '\n' );
 127   2            putchar( 'M' );putchar( 'E' );putchar( '-' );putchar( '1' );putchar( '0' );putchar( '6' );putchar( '
             - ' );putchar( '(' );putchar( 'N' );putchar( 'F' );putchar( ')' );putchar( ' ' );putchar( 'F' );putchar( 'i' );putchar( '
             -l' );putchar( 't' );putchar( 'e' );putchar( 'r' );putchar( ' ' );putchar( 'o' );putchar( 'p' );putchar( 'e' );putchar( '
             -n' );
 128   2      	   }	
 129   1      	if( tmp & 0x20  )
 130   1      	   {putchar( '\n' );
 131   2            putchar( 'M' );putchar( 'E' );putchar( '-' );putchar( '1' );putchar( '0' );putchar( '5' );putchar( '
             - ' );putchar( '(' );putchar( 'M' );putchar( 'F' );putchar( ')' );putchar( ' ' );putchar( 'F' );putchar( 'i' );putchar( '
             -l' );putchar( 't' );putchar( 'e' );putchar( 'r' );putchar( ' ' );putchar( 'o' );putchar( 'p' );putchar( 'e' );putchar( '
             -n' );
 132   2      	   }	   
 133   1      	if( tmp & 0x02  )
 134   1      	   {putchar( '\n' );
 135   2           putchar( 'M' );putchar( 'E' );putchar( '-' );putchar( '1' );putchar( '0' );putchar( '4' );putchar( ' 
             -' );putchar( '(' );putchar( 'W' );putchar( 'F' );putchar( ')' );putchar( ' ' );putchar( 'F' );putchar( 'i' );putchar( 'l
             -' );putchar( 't' );putchar( 'e' );putchar( 'r' );putchar( ' ' );putchar( 'o' );putchar( 'p' );putchar( 'e' );putchar( 'n
             -' );	
 136   2      	   }		
 137   1      
 138   1      	for( i = 0; i < 3; i++ )
 139   1      	{
 140   2      		XBYTE[ NUM_CHANNEL ] = i;
 141   2      		XBYTE[ FILTER ] = F_OUT;
 142   2      	}
 143   1      	TIMECON = 0; // Time Clock disable
 144   1      	HTHSEC = 0;
 145   1      	SEC = 0;
 146   1      	TIMECON = 0x09; // Time Clock enable
 147   1      	while( SEC < 2 );
 148   1      	tmp = XBYTE[ FILTER ];
 149   1      
 150   1          putchar( '\n' );
 151   1          putchar( 'F' );putchar( 'i' );putchar( 'l' );putchar( 'e' );putchar( 'r' );putchar( 's' );putchar( ' '
             - );putchar( 'S' );putchar( 't' );putchar( 'a' );putchar( 't' );putchar( 'e' );putchar( 's' );putchar( '=' );
 152   1          UartSendByte( tmp );
 153   1      
 154   1      	if( tmp & 0x04  )
 155   1      	   {putchar( '\n' );
 156   2            putchar( 'M' );putchar( 'E' );putchar( '-' );putchar( '1' );putchar( '0' );putchar( '6' );putchar( '
             - ' );putchar( '(' );putchar( 'N' );putchar( 'F' );putchar( ')' );putchar( ' ' );putchar( 'F' );putchar( 'i' );putchar( '
C51 COMPILER V6.12  FUNCT                                                                  07/20/2015 16:37:40 PAGE 4   

             -l' );putchar( 't' );putchar( 'e' );putchar( 'r' );putchar( ' ' );putchar( 'c' );putchar( 'l' );putchar( 'o' );putchar( '
             -s' );putchar( 'e' );
 157   2      	   }	
 158   1      	if( tmp & 0x10  )
 159   1      	   {putchar( '\n' );
 160   2            putchar( 'M' );putchar( 'E' );putchar( '-' );putchar( '1' );putchar( '0' );putchar( '5' );putchar( '
             - ' );putchar( '(' );putchar( 'M' );putchar( 'F' );putchar( ')' );putchar( ' ' );putchar( 'F' );putchar( 'i' );putchar( '
             -l' );putchar( 't' );putchar( 'e' );putchar( 'r' );putchar( ' ' );putchar( 'c' );putchar( 'l' );putchar( 'o' );putchar( '
             -s' );putchar( 'e' );	   
 161   2      	   }	
 162   1      	if( tmp & 0x01  )
 163   1      	   {putchar( '\n' );
 164   2           putchar( 'M' );putchar( 'E' );putchar( '-' );putchar( '1' );putchar( '0' );putchar( '4' );putchar( ' 
             -' );putchar( '(' );putchar( 'W' );putchar( 'F' );putchar( ')' );putchar( ' ' );putchar( 'F' );putchar( 'i' );putchar( 'l
             -' );putchar( 't' );putchar( 'e' );putchar( 'r' );putchar( ' ' );putchar( 'c' );putchar( 'l' );putchar( 'o' );putchar( 's
             -' );putchar( 'e' );	
 165   2      	   }
 166   1      
 167   1      	if( tmp != 0x15 )
 168   1      	{
 169   2      		stat =  0;
 170   2      	}
 171   1      	   
 172   1      	if( stat )
 173   1      	   {
 174   2               putchar( '\n' );
 175   2      		 putchar( '\n' ); putchar( 'C' );putchar( 'a' );putchar( 'm' );putchar( 'e' );putchar( 'r' );putchar( 'a
             -' );putchar( ' ' );putchar( 'r' );putchar( 'e' );putchar( 'a' );putchar( 'd' );putchar( 'y' );putchar( '.' );
 176   2               putchar( '\n' );
 177   2      	   }	
 178   1      
 179   1      	return stat;
 180   1      }
 181          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1224    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     10       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
