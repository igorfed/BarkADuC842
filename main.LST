C51 COMPILER V6.12  MAIN                                                                   07/20/2015 16:37:39 PAGE 1   


C51 COMPILER V6.12, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\main.OBJ
COMPILER INVOKED BY: e:\Keil\C51\BIN\C51.EXE .\main.c OPTIMIZE(9,SPEED) REGFILE(.\bark.ORC) DEBUG OBJECTEXTEND

stmt level    source

   1          #include <ADI\ADUC842.H>   /*  Use 8052&ADuC842 predefined symbols     */
   2          
   3          #include <stdio.h>	  /* prototype declarations for I/O functions */
   4          #include <ctype.h>
   5          #include <absacc.h>
   6          #include <intrins.h>
   7          #include <math.h>
   8          
   9          #include "uart.h"
  10          #include "bark.h"
  11          #include "funct.h"
  12          #include "protocol.h"
  13          #include "adc.h"
  14          #include "focus.h"
  15          
  16          //#define DEBUG_BUILD
  17          #define RS485_DEBUG_BUILD
  18          #define BUILD_WITH_CROSS
  19          
  20          void PrintAndSetParam();
  21          //void GetParam();
  22          
  23          extern char code s_exit_adc_debug[];
  24          extern char code s_copyright[];
  25          extern char code s_debug[];
  26          extern char code s_hist_error[];
  27          extern char code s_ram_error[];
  28          extern char code s_int_rs485[];
  29          
  30          //unsigned short array_index;
  31          signed short index_tmp;
  32          signed char new_change;//, cur_change, old_change[3] = {0};
  33          
  34          extern short idata shutter[];
  35          extern short idata gain[];
  36          extern unsigned char idata frame[];
  37          extern short idata index[];
  38          unsigned char data frame_limit = FRAME_LIMIT_DEF;
  39          
  40          extern struct exp code exp_table[];
  41          extern signed char code change_table[];
  42          extern signed char code change_table_av[];
  43          //extern struct st_thres data thres;
  44          extern unsigned char data average;
  45          extern unsigned char data thres_right;
  46          unsigned char thres_old1[3] = {128,128,128}, thres_old2[3] = {128,128,128};
  47          //extern unsigned long lhistsum;
  48          extern unsigned short sum;
  49          extern unsigned long lsum;
  50          //extern unsigned long l_sum;
  51          //unsigned char DUMMY00;
  52          unsigned char DUMMY01;
  53          unsigned char DUMMY02;
  54          //define SUM_OF (*(((unsigned char*)&lhistsum)+1))
  55          #define SUM_OF (*((unsigned char*)&lsum))
C51 COMPILER V6.12  MAIN                                                                   07/20/2015 16:37:39 PAGE 2   

  56          //#define L_SUM (*((unsigned char*)&l_sum))
  57          bit bAverage = 1;
  58          bit bFilterDis    = 1;
  59          bit bADCdebug     = 0;
  60          bit bAdcAutoDebug = 0;
  61          bit bDebug        = 0;
  62          char num_ch = 0;
  63          
  64          extern bit bStep;
  65          char bdata status;
  66          sbit bHistRdy = status ^ 0;
  67          sbit bRAMRdy  = status ^ 4;
  68          char bdata rs_state;
  69          sbit bRS_OK   = rs_state ^ 0;
  70          sbit bRS_ERR  = rs_state ^ 1;
  71          sbit bRS_RDY  = rs_state ^ 7;
  72          
  73          char bdata dsp_state1;
  74          sbit bNARROW = 	dsp_state1 ^ 0;
  75          sbit bMIDDLE = 	dsp_state1 ^ 1;
  76          sbit bEXT_TV = 	dsp_state1 ^ 2;
  77          sbit bFOCR = 	dsp_state1 ^ 3;
  78          sbit bCROSS =   dsp_state1 ^ 4;//перекрестие
  79          //sbit bTPV    = 	dsp_state1 ^ 5;
  80          sbit bTPV_out1 = 	dsp_state1 ^ 5;//select out1
  81          sbit bEXAM = 	dsp_state1 ^ 6;
  82          //sbit bTHERM_EN =  dsp_state1 ^ 7;//Разрешение термокоррекции
  83          sbit bTPV_out2 =  dsp_state1 ^ 7;//select out2
  84          
  85          
  86          bit bDis_Auto = 0;
  87          
  88          
  89          char bdata dsp_BVTK1;
  90          sbit bDATA_REQ = dsp_BVTK1 ^ 0;
  91          
  92          char bdata dsp_state2 = 0x28;
  93          sbit bCOMM = 	dsp_state2 ^ 2;
  94          sbit bREADY = 	dsp_state2 ^ 3;
  95          sbit bHEAT = 	dsp_state2 ^ 4;
  96          sbit bT_NORM = 	dsp_state2 ^ 5;
  97          
  98          
  99          char bdata dsp_state3;
 100          sbit bWatchDog = 	dsp_state3 ^ 0;
 101          unsigned long idata ulWatchDogCnt  = 0x00000000;
 102          
 103          bit bRS485_NEW = 0;
 104          
 105          char bdata filter_status;
 106          sbit bFILT19_OUT =  filter_status ^ 0;
 107          sbit bFILT19_IN =   filter_status ^ 1;
 108          sbit bFILT300_OUT = filter_status ^ 2;
 109          sbit bFILT300_IN =  filter_status ^ 3;
 110          sbit bFILT75_OUT =  filter_status ^ 4;
 111          sbit bFILT75_IN =   filter_status ^ 5;
 112          
 113          unsigned char temp_channel = 0;
 114          extern short code thermo[10];
 115          
 116          unsigned char idata ucCntAccADC =0;
 117          unsigned long idata ulAccADC[4]= { 0x00000000, 0x00000000, 0x00000000, 0x00000000 };
C51 COMPILER V6.12  MAIN                                                                   07/20/2015 16:37:39 PAGE 3   

 118          unsigned long idata ulAccTemp = 0;
 119          unsigned char idata ucAnalogError  = ANALOG_ERROR;
 120          unsigned char idata ucInfinity_1_5 = INFINITY_15;
 121          unsigned char idata ucFocusMin_1_5 = FOCUS_MIN_15;
 122          unsigned char idata ucFocusMax_1_5 = FOCUS_MAX_15;
 123          unsigned char idata ucFocusMin_6 = FOCUS_MIN_6;
 124          unsigned char idata ucFocusMax_6 = FOCUS_MAX_6;
 125          unsigned char idata ucInfinity_6   = INFINITY_6;
 126          unsigned char data adc_h[4] = { 0x11, 0x2F, 0x0D, 0x66 };
 127          unsigned char data adc_l[4];
 128          unsigned char idata ucRcapL = 0x00;
 129          unsigned char idata ucRcapH = 0x80;
 130          unsigned char rs_PSK3, rs_PSK2;
 131          
 132          unsigned char MemDefine;
 133          unsigned char VideoMux;
 134          unsigned char ManFocus[4];
 135          //unsigned char range_sum;
 136          bit bFocusParam = 0;
 137          unsigned char FocusRep = 0;
 138          /*
 139          bit bNEAR = 0;
 140          bit bFAR = 0;
 141          */
 142          char idata bNEAR[4] = {0};
 143          char idata bFAR[4] = {0};
 144          char idata bQ_NEAR[4]= {0};
 145          char idata bQ_FAR[4]= {0};
 146          extern unsigned char idata cDeltaFoc[4];
 147          extern unsigned char focus[4];
 148          unsigned short sFocAddr = FOCUS;
 149          //bit bMFOCUS = 0;
 150          bit bSelfExam = 0;
 151          
 152          unsigned short exp_delta = DELTA_INDEX_DEF;
 153          unsigned short index_max = INDEX_MAX - DELTA_INDEX_DEF;
 154          unsigned short shutter_limit = SHUTTER_MAX;
 155          unsigned short exp_delta_fine = 0;
 156          unsigned char temp_nord;
 157          //#define temp_nord focus[4]
 158          unsigned char corr_delay;
 159          //signed char ex_corr = 0x40; // 64
 160          signed char ex_corr = 0xC0; // -64
 161          
 162          unsigned char num_adc_ch = 0;
 163          //short nnn = 0;
 164          
 165          void Debug( void );
 166          
 167          void fFocusParamInit(void);
 168          
 169          void GetAndPrintAdcOne (unsigned char);
 170          
 171          void DelayStopMotor(unsigned long );
 172          
 173          void fTimer(unsigned char, unsigned char );
 174          
 175          void fAutoFocus(void)
 176          {
 177   1      	  short sFocAddr;
 178   1          //putchar( '\n' );putchar( 'f' );putchar( 'A' );putchar( 'u' );putchar( 't' );putchar( 'o' );  putchar
             -( 'F' );putchar( 'o' );putchar( 'c' );putchar( '\n' );
C51 COMPILER V6.12  MAIN                                                                   07/20/2015 16:37:39 PAGE 4   

 179   1      	  if(( num_adc_ch == 1 )	|| ( num_adc_ch == 2 ))	
 180   1      	       {		
 181   2      	         switch( num_adc_ch )
 182   2      			       {                     	
 183   3      			        	case 1: // focus 300 	
 184   3      				            sFocAddr = FOCUS_300;
 185   3      				            break;
 186   3      				        case 2: // focus 75		  		          
 187   3      				            sFocAddr = FOCUS_75;
 188   3      				            break;
 189   3      				        default:
 190   3      				            break;			  	   	 			  
 191   3      				     }
 192   2      /*			 if( bFAR[ num_adc_ch ] || bNEAR[ num_adc_ch ] )
 193   2      					{
 194   2      						if( ( adc_h[ num_adc_ch ] -4 ) > focus[ num_adc_ch ] )
 195   2      						{
 196   2      							if( bNEAR[ num_adc_ch ] ) 
 197   2      								{
 198   2      								bNEAR[ num_adc_ch ] = 0;
 199   2      								bFAR[ num_adc_ch ] = 0;
 200   2      								}
 201   2      							else
 202   2      								{
 203   2      								if( adc_h[ num_adc_ch ] > ( focus[ num_adc_ch ] + 8) )
 204   2      										XBYTE[ sFocAddr ] = FOC_Q_FAR;
 205   2      								else	XBYTE[ sFocAddr ] = FOC_FAR;
 206   2      								bFAR[ num_adc_ch ] = 1;
 207   2      								}
 208   2      						}
 209   2      						else
 210   2      						   {
 211   2      							if( (adc_h[ num_adc_ch ]-4 ) < focus[ num_adc_ch ] ) //-1//2
 212   2      							   {
 213   2      								if( bFAR[ num_adc_ch ] ) // if we did "far" and drove over
 214   2      								   {
 215   2      		
 216   2      									XBYTE[ sFocAddr ] = FOC_Q_STOP;
 217   2      									XBYTE[ sFocAddr ] = FOC_STOP;
 218   2      									bNEAR[ num_adc_ch ] = 0;
 219   2      									bFAR[ num_adc_ch ] = 0;
 220   2      								   }
 221   2      								else
 222   2      								   {
 223   2      									XBYTE[ sFocAddr ] = FOC_Q_NEAR;
 224   2      									bNEAR[ num_adc_ch ] = 1;
 225   2      							 	   }
 226   2      							   }
 227   2      							else
 228   2      							   {
 229   2      								XBYTE[ sFocAddr ] = FOC_Q_STOP; // if adc_h[ num_adc_ch ] == focus[ num_adc_ch ]
 230   2      								XBYTE[ sFocAddr ] = FOC_STOP;
 231   2      								bNEAR[ num_adc_ch ] = 0;
 232   2      								bFAR[ num_adc_ch ] = 0;
 233   2      							   }
 234   2      						   }
 235   2      					}// endif( bFAR || bNEAR )
 236   2      					else
 237   2      					{*/
 238   2      						if( adc_h[ num_adc_ch ] - 1 > focus[ num_adc_ch ] )
 239   2      						{
 240   3      							XBYTE[ sFocAddr ] = FOC_Q_FAR;
C51 COMPILER V6.12  MAIN                                                                   07/20/2015 16:37:39 PAGE 5   

 241   3      							bFAR[ num_adc_ch ] = 1;
 242   3      						}
 243   2      						else
 244   2      						{
 245   3      							if( adc_h[ num_adc_ch ] < focus[ num_adc_ch ] )
 246   3      							{
 247   4      								XBYTE[ sFocAddr ] = FOC_Q_NEAR;
 248   4      								bNEAR[ num_adc_ch ] = 1;
 249   4      							}
 250   3      							else
 251   3      							{
 252   4      								XBYTE[ sFocAddr ] = FOC_Q_STOP; 
 253   4      								XBYTE[ sFocAddr ] = FOC_STOP;
 254   4      							}
 255   3      						}
 256   2      				//	}				     
 257   2      
 258   2      				 } 
 259   1          
 260   1          if( (++num_adc_ch) == 4 )
 261   1               {
 262   2                num_adc_ch = 1;
 263   2                //temp_nord = adc_h[3]- 73 + (char)ucAnalogError;
 264   2                //putchar( '\n' );putchar( 'T' );putchar( 'M' );putchar( 'P' );putchar( ' ' );putchar( 'N' );  p
             -utchar( 'O' );putchar( 'R' );putchar( 'D' );putchar( '\n' );
 265   2                temp_nord = XBYTE[ THERMO_NORD ];
 266   2                if( corr_delay == 0 ) FocusThermoCorrection( temp_nord ); 
 267   2                corr_delay++;				         
 268   2               } 
 269   1          if( num_adc_ch == 1)   ADCCON2 = ADCS_1_5;		    
 270   1          if( num_adc_ch == 2)   ADCCON2 = ADCS_6;		
 271   1          if( num_adc_ch == 3)   ADCCON2 = ADCS_EXT_T_SENSE;		
 272   1      }
 273          
 274          void CalcExpDelta()
 275          {
 276   1      	// выключить ограничение длительности затвора
 277   1      	shutter_limit = SHUTTER_MAX;
 278   1      	exp_delta_fine = 0;
 279   1      	//-------------------------------------------
 280   1      	switch( frame_limit )
 281   1      	{
 282   2      		case 0:
 283   2      			exp_delta = DELTA_INDEX0;
 284   2      			index_max = INDEX_MAX - DELTA_INDEX0;
 285   2      			break;
 286   2      		case 1:
 287   2      			exp_delta = DELTA_INDEX1;
 288   2      			index_max = INDEX_MAX - DELTA_INDEX1;
 289   2      			break;
 290   2      		default:
 291   2      			if( frame_limit >= 250 )
 292   2      			{
 293   3      				exp_delta = DELTA_INDEX250;
 294   3      				index_max = INDEX_MAX - DELTA_INDEX250;
 295   3      			}
 296   2      			else
 297   2      			{
 298   3      				exp_delta = 0;
 299   3      				while( exp_table[ INDEX_GAIN - exp_delta ].frame > frame_limit )
 300   3      				{
 301   4      					exp_delta++;
C51 COMPILER V6.12  MAIN                                                                   07/20/2015 16:37:39 PAGE 6   

 302   4      				}
 303   3      				index_max = INDEX_MAX - exp_delta;
 304   3      			}
 305   2      	}// end of switch
 306   1      }
 307          
 308          void CalcExpDeltaFine()
 309          {
 310   1      		if( shutter_limit >= SHUTTER_MAX )
 311   1      		{
 312   2      				exp_delta_fine = 0;
 313   2      				//Выключить ограничение накопления
 314   2      				frame_limit = FRAME_LIMIT_DEF;
 315   2      				exp_delta = DELTA_INDEX_DEF;
 316   2      				index_max = INDEX_MAX - DELTA_INDEX_DEF;
 317   2      		}
 318   1      		else
 319   1      		{
 320   2      				//Включить ограничение накопления до 1 кадра
 321   2      				frame_limit = 0;
 322   2      				exp_delta = DELTA_INDEX0;
 323   2      				//---------------------------------------------
 324   2      				exp_delta_fine = 0;
 325   2      				while( exp_table[ INDEX_GAIN_FINE - exp_delta_fine ].shutter > shutter_limit )
 326   2      				{
 327   3      					exp_delta_fine++;
 328   3      				}
 329   2      				index_max = INDEX_MAX - DELTA_INDEX0 - exp_delta_fine;
 330   2      		}
 331   1      }
 332          
 333          void int_RS485 (void) interrupt 0 /* using 3 */
 334          {
 335   1      	unsigned char n;
 336   1      	unsigned char *ptr, filter_ch;
 337   1      	unsigned short array_index;
 338   1      	rs_state = XBYTE[ RS485_CTRL ]; 
 339   1      	if( bRS_OK )
 340   1      	{
 341   2      		bRS485_NEW = 1;
 342   2      		XBYTE[MEM_DEFINE] = MEM_RS485;
 343   2      		XBYTE[MEM_ADDR] = 1;
 344   2      	    for( n = 0; n < 10; n++ )
 345   2      	     {
 346   3      	     }
 347   2      		dsp_state1 = XBYTE[MEM_DATA_L];
 348   2      		XBYTE[VIDEO_MUX] = dsp_state1 & 0xA3;
 349   2      		VideoMux = dsp_state1 & 0x03;
 350   2      
 351   2      #ifdef BUILD_WITH_CROSS
 352   2      		//перекрестие
 353   2      		XBYTE[NUM_CHANNEL] = VideoMux;
 354   2      		if( bCROSS)
 355   2      		{
 356   3      			XBYTE[0x3cFF] = 0x10;
 357   3      		}
 358   2      		else
 359   2      		{
 360   3      			XBYTE[0x3cFF] = 0x00;
 361   3      		}
 362   2      		XBYTE[NUM_CHANNEL]= num_ch;
 363   2      		//end перекрестие
C51 COMPILER V6.12  MAIN                                                                   07/20/2015 16:37:39 PAGE 7   

 364   2      #endif
 365   2      //*******************************		
 366   2      //*******************************		
 367   2      		//XBYTE[VIDEO_MUX] = dsp_state1 & 0x23;	
 368   2      		dsp_BVTK1 = XBYTE[MEM_DATA_L];	// read command if it exist
 369   2                                            //  БИТ5       БИТ6
 370   2      		if( !bTPV_out1)//                   bTPV_out1  bTPV_out2
 371   2      		    {
 372   3      		     if( !bTPV_out2) //                0          0   
 373   3      		     	   XBYTE[VIDEO_MUX] =   dsp_state1 & VIDEO_CHANNELS_MASK;
 374   3      		     else            //                0          1
 375   3      		     	   XBYTE[VIDEO_MUX] =  (dsp_state1 & 0x03)|0x40; 
 376   3      		    }
 377   2      		else                              //bTPV_out1  bTPV_out2
 378   2      		    {
 379   3      		     if( !bTPV_out2) //                1          0   
 380   3      		     	   XBYTE[VIDEO_MUX] =  (dsp_state1 & 0x03)|0x20; 
 381   3      		     else            //                1          1
 382   3      		     	   XBYTE[VIDEO_MUX] =  (dsp_state1 & 0x03)|0x60; 
 383   3      		    }		
 384   2      //*******************************	
 385   2      //*******************************
 386   2      			switch( dsp_BVTK1 & PARAM_MASK )
 387   2      			{
 388   3      				case PARAM_EXP:
 389   3      					ptr = (unsigned char*)&index[ VideoMux ];
 390   3      					break;
 391   3      				case PARAM_GAIN:
 392   3      					ptr = (unsigned char*)&gain[ VideoMux ];
 393   3      					break;
 394   3      				case PARAM_SHUT:
 395   3      					ptr = (unsigned char*)&shutter[ VideoMux ];
 396   3      					break;
 397   3      				case PARAM_FRAME:
 398   3      					ptr = (unsigned char*)&frame[ VideoMux ];
 399   3      					break;
 400   3      				case PARAM_FILTER_300:
 401   3      					filter_ch = NORD300;
 402   3      					break;
 403   3      				case PARAM_FILTER_75:
 404   3      					filter_ch = NORD75;
 405   3      					break;
 406   3      				case PARAM_FILTER_19:
 407   3      					filter_ch = NORD19;
 408   3      					break;
 409   3      				default:;
 410   3      			}
 411   2      			switch( dsp_BVTK1 & PARAM_MASK )
 412   2      			{
 413   3      				case PARAM_EXP:
 414   3      				case PARAM_GAIN:
 415   3      				case PARAM_SHUT:
 416   3      					if( !bDATA_REQ )
 417   3      					{
 418   4      						*ptr = XBYTE[MEM_DATA_L]; //high byte of short (BVTK2)
 419   4      					}
 420   3      					rs_PSK2 = *ptr++; //high byte of short (PSK2)
 421   3      				case PARAM_FRAME:
 422   3      					if( !bDATA_REQ )
 423   3      					{
 424   4      						*ptr = XBYTE[MEM_DATA_L]; //low byte of short (BVTK3)
 425   4      					}
C51 COMPILER V6.12  MAIN                                                                   07/20/2015 16:37:39 PAGE 8   

 426   3      					rs_PSK3 = *ptr; //low byte of short (PSK3)
 427   3      					if( dsp_BVTK1 == PARAM_EXP )
 428   3      					{
 429   4      						array_index = index[ VideoMux ];
 430   4      						shutter[ VideoMux ] = exp_table[ array_index ].shutter;
 431   4      						gain[ VideoMux ] = exp_table[ array_index ].gain;
 432   4      						frame[ VideoMux ] = exp_table[ array_index ].frame;
 433   4      					}
 434   3      					break;
 435   3      				case PARAM_FILTER_300:
 436   3      				case PARAM_FILTER_75:
 437   3      				case PARAM_FILTER_19:
 438   3      					if( !bDATA_REQ )
 439   3      					{
 440   4      						XBYTE[ NUM_CHANNEL ] = filter_ch;
 441   4      						XBYTE[ FILTER ] = XBYTE[MEM_DATA_L];
 442   4      						XBYTE[ NUM_CHANNEL ] = num_ch;
 443   4      					}
 444   3      					rs_PSK2 = 0;
 445   3      					rs_PSK3 = XBYTE[ FILTER ];
 446   3      					break;
 447   3      				case PARAM_LIMIT:
 448   3      					if( !bDATA_REQ )
 449   3      					{
 450   4      						frame_limit = XBYTE[MEM_DATA_L];
 451   4      						CalcExpDelta();
 452   4      					}
 453   3      					rs_PSK3 = frame_limit;
 454   3      					break;
 455   3      					
 456   3      				case PARAM_SHUTTER_LIMIT:
 457   3      					if( !bDATA_REQ )
 458   3      					{
 459   4      						*((char*)&shutter_limit) = XBYTE[MEM_DATA_L]; // Hi byte
 460   4      					    for( n = 0; n < 10; n++ )
 461   4      					     {
 462   5      					     }
 463   4      						*((char*)&shutter_limit+1) = XBYTE[MEM_DATA_L]; // Lo byte
 464   4      						CalcExpDeltaFine();
 465   4      					}
 466   3      					rs_PSK2 = *((char*)&shutter_limit);
 467   3      					rs_PSK3 = *((char*)&shutter_limit+1);
 468   3      					break;
 469   3      					
 470   3      				case PARAM_FOCUS:
 471   3      					if( bFOCR )
 472   3      					if( !bDATA_REQ )
 473   3      					{
 474   4      						ManFocus[ VideoMux ] = XBYTE[MEM_DATA_L]; // BVTK2;
 475   4      						bFocusParam = 1;
 476   4      					}
 477   3      					rs_PSK2 = adc_h[ VideoMux ];
 478   3      					rs_PSK3 = adc_l[ VideoMux ];
 479   3      					break;
 480   3      					
 481   3      				case TEMP_ACK:
 482   3      					rs_PSK2 = thermo[ temp_channel++ ];
 483   3      					rs_PSK3 = XBYTE[ thermo[ temp_channel++ ] ];//изиенение в 5-м битеXBYTE
 484   3      					if (temp_channel == 10)
 485   3      					    {
 486   4      			         temp_channel = 0; 
 487   4              			 rs_PSK3 = temp_nord;
C51 COMPILER V6.12  MAIN                                                                   07/20/2015 16:37:39 PAGE 9   

 488   4      					    }
 489   3      					if( ( rs_PSK3 < 65 ) || ( rs_PSK3 > 216 ) )
 490   3      					    {
 491   4      					     bHEAT = 0;//0
 492   4      					     bT_NORM = 1;//1
 493   4      					    }
 494   3      					else
 495   3      					    {
 496   4      					     bT_NORM = 0;//0
 497   4      						   if( rs_PSK3 < 128  )
 498   4      						       {
 499   5      							      bHEAT = 1;//1
 500   5      						       }
 501   4      						   else
 502   4      						       {
 503   5      							      bHEAT = 0;//0
 504   5      						       }
 505   4      					    }
 506   3      					break;
 507   3      					
 508   3      				case WINDOW_AV:
 509   3      					rs_PSK2 = XBYTE[MEM_DATA_L]; //dummy
 510   3      					if( !bDATA_REQ )
 511   3      					{
 512   4      					    for( n = 0; n < 10; n++ )
 513   4      					     {
 514   5      					     }
 515   4      						XBYTE[ DSP_CTRL ] = XBYTE[MEM_DATA_L];
 516   4      					}
 517   3      				    for( n = 0; n < 10; n++ )
 518   3      				     {
 519   4      				     }
 520   3      					rs_PSK3 = XBYTE[ DSP_CTRL ];
 521   3      					break;
 522   3      				default:;
 523   3      			}
 524   2      		
 525   2      		if( bFOCR )
 526   2      		{
 527   3      			//_nop_();
 528   3      			switch( dsp_BVTK1 ) //& PARAM_MASK )
 529   3      			{
 530   4      				case PARAM_LO:
 531   4      					if( FocusRep < TYPEMATIC_DELAY )
 532   4      					{
 533   5      						FocusRep++;
 534   5      						XBYTE[FOCUS] = FOC_NEAR;
 535   5      					}
 536   4      					else
 537   4      					{
 538   5      						XBYTE[FOCUS] = FOC_Q_NEAR;
 539   5      					}
 540   4      					rs_PSK2 = adc_h[ VideoMux ];
 541   4      					rs_PSK3 = adc_l[ VideoMux ];
 542   4      					break;
 543   4      				case PARAM_MO:
 544   4      					if( FocusRep < TYPEMATIC_DELAY )
 545   4      					{
 546   5      						FocusRep++;
 547   5      						XBYTE[FOCUS] = FOC_FAR;
 548   5      					}
 549   4      					else
C51 COMPILER V6.12  MAIN                                                                   07/20/2015 16:37:39 PAGE 10  

 550   4      					{
 551   5      						XBYTE[FOCUS] = FOC_Q_FAR;
 552   5      					}
 553   4      					rs_PSK2 = adc_h[ VideoMux ];
 554   4      					rs_PSK3 = adc_l[ VideoMux ];
 555   4      					break;
 556   4      				default:;
 557   4      					FocusRep = 0;
 558   4      					XBYTE[FOCUS] = FOC_Q_STOP;
 559   4      					XBYTE[FOCUS] = FOC_STOP;
 560   4      			}
 561   3      		}//endif( bFOCR )
 562   2      		else
 563   2      		{
 564   3      				bFocusParam = 0;
 565   3      		}
 566   2      		XBYTE[MEM_ADDR] = 0;
 567   2      		XBYTE[MEM_DATA_L] = ME_ADDR;
 568   2      		XBYTE[MEM_DATA_L] = dsp_state1;//0x05;//dsp_state1;
 569   2      		XBYTE[MEM_DATA_L] = dsp_state2;//0x00;//dsp_state2;
 570   2      		XBYTE[MEM_DATA_L] = dsp_BVTK1; //0x05;//dsp_BVTK1;		//PSK1
 571   2      		XBYTE[MEM_DATA_L] = rs_PSK2;   //0x00;//rs_adc;		//PSK2
 572   2      		XBYTE[MEM_DATA_L] = rs_PSK3;   //0x05;//rs_temp;		//PSK3
 573   2      		XBYTE[MEM_DEFINE] = MemDefine; //restore previous value of MEM_DEFINE
 574   2      	}
 575   1      
 576   1      }
 577          
 578          void SaveADC( unsigned char adch, unsigned char adcl ) // thanks to the Analog Devices ( see ERRATA824_A1.
             -pdf #824_01 )
 579          {
 580   1      	unsigned short usADC = 0;			
 581   1          char cData, ch1;
 582   1      	*((unsigned char*)&usADC)   = adch & ADC_MASK; 
 583   1      	*((unsigned char*)&usADC+1) = adcl;
 584   1      	
 585   1      
 586   1      
 587   1      	if(num_adc_ch != 3)		
 588   1      		  {	
 589   2      	     ulAccADC[ num_adc_ch ] = (unsigned long)usADC<<5;		  	
 590   2       	     adc_h[ num_adc_ch ] = *((unsigned char*)&ulAccADC[ num_adc_ch ]+2);  
 591   2       	     adc_l[ num_adc_ch ] = *((unsigned char*)&ulAccADC[ num_adc_ch ]+3);
 592   2      	     ulAccADC[ num_adc_ch ] = 0;  	     
 593   2       	 	 	}
 594   1       	else
 595   1       		  {
 596   2      		   adc_h[ num_adc_ch ] = XBYTE[ THERMO_NORD ]; 
 597   2      /*
 598   2      		   ulAccTemp += (unsigned long)usADC;
 599   2      		   if(ucCntAccADC== 0x1F)		
 600   2      		       {
 601   2          	    	ucCntAccADC = 0xFF;	
 602   2       	          adc_h[ num_adc_ch ] = *((unsigned char*)&ulAccTemp+2);  
 603   2       	          adc_l[ num_adc_ch ] = *((unsigned char*)&ulAccTemp+3);
 604   2          	    	ulAccTemp = 0;    	    		       	
 605   2      		       }    
 606   2                  ucCntAccADC ++;	
 607   2      //*/ 	
 608   2       			}
 609   1      
 610   1      	if(  bDebug == 1) 
C51 COMPILER V6.12  MAIN                                                                   07/20/2015 16:37:39 PAGE 11  

 611   1      		  {   	 
 612   2      			if( RI )
 613   2      			   {
 614   3      	    	    ch1 = getchar();
 615   3      	    	    ch1 = toupper( ch1 );	
 616   3      	    	    switch( ch1 )
 617   3      				    {
 618   4      				     case 'E':	//auto focusing stop
 619   4      	            		 bADCdebug = 0;
 620   4      	            		 bDebug    = 0;
 621   4      	         			 puts( s_exit_adc_debug );                        
 622   4      				         break;
 623   4      	
 624   4      				     default:
 625   4      		         		 break;
 626   4      	                 }
 627   3      	           }
 628   2      	
 629   2      		   if(num_adc_ch != 3)		
 630   2      		       {
 631   3                  putchar('\n');putchar( 'F' );putchar( 'o' );putchar( 'c' );putchar( 'u' );putchar( 's' );UartS
             -endByte( num_adc_ch  );putchar( ' ' );
 632   3                       
 633   3      		        if(num_adc_ch == 1)
 634   3      		   	        {
 635   4                             putchar( 'M' );putchar( 'E' );putchar( '-' );putchar( '1' );putchar( '0' );putchar(
             - '6' );putchar( ' ' );
 636   4      		   	        }
 637   3      		        if(num_adc_ch == 2)
 638   3      		   	        {
 639   4      		             putchar( 'M' );putchar( 'E' );putchar( '-' );putchar( '1' );putchar( '0' );putchar( '5' );p
             -utchar( ' ' );
 640   4      		   	        }	
 641   3      		   	    putchar( 'R' );putchar( '=' );putchar( '0' );putchar( 'x' ); 	 	
 642   3      		        UartSendByte( adc_h[ num_adc_ch ] );putchar( ' ' );		 	
 643   3      		        putchar( 'T' );putchar( 'e' );putchar( 'm' );putchar( 'p' );putchar( ' ' );putchar( 'N' );putcha
             -r( 'o' );putchar( 'r' );putchar( 'd' );putchar( ' ' );putchar( '0' );putchar( 'x' );
 644   3      		        //cData = adc_h[3]- 73 + (char)ucAnalogError;
 645   3      		        cData = XBYTE[ THERMO_NORD ]; 
 646   3      		        UartSendByte( cData );
 647   3      		       }
 648   2      	     else
 649   2      		       {
 650   3      		        putchar('\n');
 651   3      		        //putchar( 'A' );putchar( 'D' );putchar( 'C' );UartSendByte( adc_h[3] );putchar( ' ' );
 652   3      		        putchar( 'T' );putchar( 'e' );putchar( 'm' );putchar( 'p' );putchar( ' ' );putchar( 'N' );putcha
             -r( 'o' );putchar( 'r' );putchar( 'd' );putchar( ' ' );putchar( '0' );putchar( 'x' );
 653   3      		        //cData = adc_h[3]- 73 + (char)ucAnalogError;
 654   3      		        cData = XBYTE[ THERMO_NORD ]; 
 655   3      		        UartSendByte( cData );		  	
 656   3      			     }
 657   2      	     putchar( '\n' ); 	
 658   2      		  }				 	
 659   1      }
 660          
 661          
 662          //???????????????
 663          void int_ADC (void) interrupt 6
 664          {
 665   1        //putchar( '\n' );putchar( 'i' );putchar( 'n' );putchar( 't' );putchar( ' ' );putchar( 'A' );  putchar( 
             -'D' );putchar( 'C' );putchar( '\n' );
 666   1      
C51 COMPILER V6.12  MAIN                                                                   07/20/2015 16:37:39 PAGE 12  

 667   1      	T2CON &= 0x7F;	
 668   1      
 669   1        SaveADC( ADCDATAH, ADCDATAL );	 
 670   1      	    
 671   1      	if( !bADCdebug )  
 672   1      ///*
 673   1      	   {   	
 674   2      		   if( bFOCR )
 675   2      		      {
 676   3      		       if( bFocusParam )
 677   3      		           {
 678   4      		            if( ( num_adc_ch == VideoMux ) )
 679   4      		                {
 680   5      				             if( bFAR[ num_adc_ch ] || bNEAR[ num_adc_ch ] )
 681   5      				                {
 682   6      					               if( (adc_h[ num_adc_ch ] ) > ManFocus[ num_adc_ch ] )// if motor is on the adc value i
             -s larger than the real position -1
 683   6      					                   {
 684   7      						                  if( bNEAR[ num_adc_ch ] ) // if we did "near" and drove over
 685   7      						                      {
 686   8      
 687   8      							                     XBYTE[FOCUS] = FOC_Q_STOP;
 688   8      							                     XBYTE[FOCUS] = FOC_STOP;
 689   8      							                     bNEAR[ num_adc_ch ] = 0;
 690   8      							                     bFAR[ num_adc_ch ] = 0;
 691   8      						                      }
 692   7      						                  else
 693   7      						                      {
 694   8      
 695   8      							                     XBYTE[FOCUS] = FOC_FAR;
 696   8      							                     bFAR[ num_adc_ch ] = 1;
 697   8      						                      }
 698   7      					                   }
 699   6      					               else
 700   6      					                   {
 701   7      						                  if( (adc_h[ num_adc_ch ] ) < ManFocus[ num_adc_ch ] ) // if motor is on the adc va
             -lue is larger than the real position -1
 702   7      						                      {
 703   8      							                  if( bFAR[ num_adc_ch ] ) // if we did "far" and drove over
 704   8      							                      {
 705   9      
 706   9      							                    	XBYTE[FOCUS] = FOC_Q_STOP;
 707   9      								                    XBYTE[FOCUS] = FOC_STOP;
 708   9      								                    bNEAR[ num_adc_ch ] = 0;
 709   9      								                    bFAR[ num_adc_ch ] = 0;
 710   9      							                      }
 711   8      							                  else
 712   8      							                      {
 713   9      
 714   9      								                     XBYTE[FOCUS] = FOC_NEAR;
 715   9      								                     bNEAR[ num_adc_ch ] = 1;
 716   9      							                      }
 717   8      						                      }
 718   7      						                  else
 719   7      						                    	{
 720   8      
 721   8      							                     XBYTE[FOCUS] = FOC_Q_STOP; // if adc_h[ num_adc_ch ] == ManFocus
 722   8      							                     XBYTE[FOCUS] = FOC_STOP;
 723   8      							                     bNEAR[ num_adc_ch ] = 0;
 724   8      							                     bFAR[ num_adc_ch ] = 0;
 725   8      						                      }
 726   7      					                   }
C51 COMPILER V6.12  MAIN                                                                   07/20/2015 16:37:39 PAGE 13  

 727   6      				                }// endif( bFAR || bNEAR )
 728   5      				             else
 729   5      				                {
 730   6      				               	 if( adc_h[ num_adc_ch ] > ManFocus[ num_adc_ch ] )
 731   6      					                   {
 732   7      
 733   7      						                  XBYTE[FOCUS] = FOC_FAR;
 734   7      						                  bFAR[ num_adc_ch ] = 1;
 735   7      					                   }
 736   6      					               else
 737   6      					                   {
 738   7      					                  	if( adc_h[ num_adc_ch ] < ManFocus[ num_adc_ch ] )
 739   7      					                      	{
 740   8      
 741   8      							                     XBYTE[FOCUS] = FOC_NEAR;
 742   8      							                     bNEAR[ num_adc_ch ] = 1;
 743   8      						                      }
 744   7      						                  else
 745   7      						                      {
 746   8      
 747   8      						                       XBYTE[FOCUS] = FOC_Q_STOP; // if adc_h[ num_adc_ch ] == ManFocus
 748   8      							                     XBYTE[FOCUS] = FOC_STOP;
 749   8      						                      }
 750   7      					                   }
 751   6      				                }
 752   5      		                }// endif( num_adc_ch == VideoMux )
 753   4      		           }// endif ( bFocusParam )
 754   3      		      }//endif( bFOCR )
 755   2      		   else// else if( bFOCR )
 756   2      		      {
 757   3      		       fAutoFocus();             			                     		                   	                       
 758   3      	        }
 759   2      	    }  
 760   1      }
 761          //???????????????
 762          
 763          void CheckRamReady()
 764          {
 765   1      	unsigned char i, j;
 766   1      			bRAMRdy = 0;
 767   1      			i = 100; // 5000 * 10us = 50ms
 768   1      			do
 769   1      			{
 770   2      			  j = 100;
 771   2      			  do
 772   2      			  {
 773   3      				status = XBYTE[ HIST_CONTROL ];
 774   3      				if( bRAMRdy )
 775   3      				{
 776   4      					goto skip1;
 777   4      				}
 778   3      			  } while( --j!=0 );
 779   2      			} while( --i!=0 );
 780   1        skip1:
 781   1      			if( !bRAMRdy ) puts( s_ram_error );
 782   1      }
 783          /*------------------------------------------------
 784          The main C function.  Program execution starts
 785          here after stack initialization.
 786          ------------------------------------------------*/
 787          void main (void)
 788          {
C51 COMPILER V6.12  MAIN                                                                   07/20/2015 16:37:39 PAGE 14  

 789   1      char ch, num_char = 0;
 790   1      	unsigned char i, j, k;
 791   1      	//unsigned short array_index;
 792   1      	bit bFiltIn = 0;
 793   1      	char n= 0, rs_data;
 794   1      
 795   1      	PLLCON = 1;  	/* Установить PLL на 12.582912 МГц */
 796   1      
 797   1      	UartInit();
 798   1      
 799   1          fFocusParamInit();
 800   1        	
 801   1      	RCAP2L  = ucRcapL; 
 802   1      	RCAP2H  = ucRcapH; 
 803   1      	TL2	= 0x00; 	 
 804   1      	TH2	= 0x00;		
 805   1      
 806   1      	EADRH = 0x00;
 807   1      	EADRL = 0x02;
 808   1      	ECON = 1;
 809   1      	ECON = 4;
 810   1          putchar('\n');putchar( 'M' );putchar( 'E' );putchar( '-' );putchar( '1' );putchar( '0' );putchar( '8' 
             -);putchar( ' ' );putchar( '#' );
 811   1      	for( i = 1; i < 4; i++ )
 812   1      	   {
 813   2              switch( i )
 814   2      	       {
 815   3         		    case 1:
 816   3      		        j = EDATA1;
 817   3      		     	UartSendByte( j );
 818   3      	            break;
 819   3         		    case 2:
 820   3      		     	j = EDATA2;
 821   3      		     	UartSendByte( j );
 822   3      	            break;
 823   3         		    case 3:
 824   3      		     	j = EDATA3;
 825   3      		     	UartSendByte( j );
 826   3      	            break;
 827   3      		      default:
 828   3      	            break;
 829   3               }
 830   2      	   }
 831   1      
 832   1      	EADRH = 0x00;
 833   1      	EADRL = 0x04;
 834   1      	ECON = 1;
 835   1      	ECON = 4;	   
 836   1          putchar( ' ' );  putchar( 'l' );  putchar( 'o' );  putchar( 'a' );  putchar( 'd' );  putchar( 'e' );  
             -putchar( 'd' );  putchar( ' ' );
 837   1      //"loaded 09.07.2012"
 838   1      	for( i = 1; i < 5; i++ )
 839   1      	   {
 840   2              switch( i )
 841   2      	       {
 842   3         		    case 1:
 843   3      		        j = EDATA1;
 844   3      		     	UartSendByte( j );
 845   3                      putchar( '.' );
 846   3      	            break;
 847   3         		    case 2:
 848   3      		     	j = EDATA2;
C51 COMPILER V6.12  MAIN                                                                   07/20/2015 16:37:39 PAGE 15  

 849   3      		     	UartSendByte( j );
 850   3                      putchar( '.' );
 851   3      	            break;
 852   3         		    case 3:
 853   3      		     	j = EDATA3;
 854   3      		     	UartSendByte( j );
 855   3      	            break;
 856   3         		    case 4:
 857   3      		     	j = EDATA4;
 858   3      		     	UartSendByte( j );
 859   3      	            break;
 860   3      		    default:
 861   3      	            break;
 862   3               }
 863   2      	   }
 864   1      	puts( s_copyright );
 865   1      			  UartSendWord( INDEX_FILT_IN );
 866   1      					  puts("\n ");
 867   1      			  UartSendWord( INDEX_FILT_OUT );
 868   1      					  puts("\n ");
 869   1      
 870   1      
 871   1      
 872   1      	EX0 = 1;		// Разрешить прерывание от INT0 
 873   1      	EX1 = 0;		// Разрешить прерывание от INT1 
 874   1      	EA  = 1;			// Разрешить прерывания 		
 875   1      
 876   1      	EADC	= 1;
 877   1      	ADCCON1 = ADC_POWER_UP;	
 878   1          ADCCON2 = ADCS_INT_T_SENSE;
 879   1      	//ADCCON2 = ADCS_EXT_T_SENSE;  
 880   1        
 881   1      	T2CON  |= 0x04;
 882   1      
 883   1      	dsp_state3 = XBYTE[ A_WD_STATE ];
 884   1      //not watch dog reset
 885   1          if(!bWatchDog)
 886   1      	    {	
 887   2      		/* Init RS-485 */
 888   2      		XBYTE[ RS485_CTRL ] = RS_PRESET;
 889   2      		XBYTE[ RS485_NSND ] = NUM_BYTE_TX;
 890   2      		XBYTE[ RS485_NRCV ] = NUM_BYTE_RX;
 891   2      		XBYTE[ RS485_ERR  ] = 100;
 892   2      
 893   2      	    XBYTE[ VIDEO_MUX  ] = NORD75;
 894   2      		//установим таймаут до сброса, длина цепи собаки
 895   2      		/*
 896   2      	    EADRH = 0x00;
 897   2      	    EADRL = 0x08;						         
 898   2      		ECON = 1;
 899   2      	    ECON = 4;
 900   2      		XBYTE[A_WD_PRESET_0] = EDATA4;//00
 901   2      		XBYTE[A_WD_PRESET_1] = EDATA3;//00
 902   2      		XBYTE[A_WD_PRESET_2] = EDATA2;//00
 903   2      		XBYTE[A_WD_PRESET_3] = EDATA1;//E0
 904   2      	    //*/
 905   2              ///*
 906   2      		XBYTE[A_WD_PRESET_0] = 0x00;//00
 907   2      		XBYTE[A_WD_PRESET_1] = 0x00;//00
 908   2      		XBYTE[A_WD_PRESET_2] = 0x00;//00
 909   2      		XBYTE[A_WD_PRESET_3] = 0x00;//E0
 910   2      		//*/
C51 COMPILER V6.12  MAIN                                                                   07/20/2015 16:37:39 PAGE 16  

 911   2      		XBYTE[A_WD_CTRL]     = 0x03; //ЗАГРУЗКА  собаку посадили на цепь
 912   2      	
 913   2      	    #ifdef DEBUG_BUILD
              	          bDebug = 1;
              		      XBYTE[A_WD_CTRL]  = 0x03; //погладим собаку и посадим на цепь ЗАГРУЗКА 
              		      Debug();
              	    #endif
 918   2      	
 919   2      		bREADY = SelfExamine();
 920   2      	  	XBYTE[A_WD_CTRL]  = 0x01;//РАЗРЕШЕНИЕ СЧЁТА
 921   2      	
 922   2      		k = 2;
 923   2      		do
 924   2      			{
 925   3      				XBYTE[ NUM_CHANNEL ] = k;
 926   3      					bRAMRdy = 0;
 927   3      					i = 100; // 5000 * 10us = 50ms
 928   3      					do
 929   3      					{
 930   4      					  j = 100;
 931   4      					  do
 932   4      					  {
 933   5      						status = XBYTE[ HIST_CONTROL ];
 934   5      						if( bRAMRdy )
 935   5      						{
 936   6      							goto skip;
 937   6      						}
 938   5      					  } while( --j!=0 );
 939   4      					} while( --i!=0 );
 940   3      		     skip:
 941   3      					if( !bRAMRdy ) puts( s_ram_error );
 942   3      					XBYTE[A_FRAME]      = FRAME_DEFAULT;
 943   3      					XBYTE[A_SHUTTER_H]  = SHUTTER_DEFAULT_HI;//*((char*)&tmp_param);
 944   3      					XBYTE[A_SHUTTER_L]  = SHUTTER_DEFAULT_LO;
 945   3      					XBYTE[A_GAIN_H]     = GAIN_DEFAULT_HI;
 946   3      					XBYTE[A_GAIN_L]     = GAIN_DEFAULT_LO;
 947   3      					XBYTE[HIST_CONTROL] = HIST_REQ;
 948   3      			} while( --k != 0 );
 949   2      	   }//собака на цепи
 950   1        else//собака укусила
 951   1        {
 952   2          putchar('\n');putchar( 'W' );putchar( '_' );putchar( 'D' );putchar( 'o' );putchar( 'g' );putchar( 'C' 
             -);putchar( 'n' );putchar( 't' );
 953   2       
 954   2      	XBYTE[A_WD_CTRL]  = 0x03; //погладим собаку и посадим на цепь ЗАГРУЗКА 
 955   2      	XBYTE[A_WD_STATE] = 0x00; //сбросим флаг,  
 956   2      	XBYTE[A_WD_CTRL]  = 0x01; //РАЗРЕШЕНИЕ СЧЁТА 
 957   2          //читаем счётчик срабатываний по W.D.
 958   2          EADRH = 0x00;
 959   2          EADRL = 0x07;						         
 960   2      	ECON = 1;
 961   2          ECON = 4;
 962   2          for( i = 0; i < 4; i++ )
 963   2             {
 964   3              switch( i )
 965   3                 {
 966   4                  case 0:
 967   4           	        *((unsigned char*)&ulWatchDogCnt)   = EDATA1;
 968   4      				putchar( ' ' );
 969   4                      UartSendByte( EDATA1 );
 970   4                      putchar(' ');
 971   4                      break;
C51 COMPILER V6.12  MAIN                                                                   07/20/2015 16:37:39 PAGE 17  

 972   4                  case 1:
 973   4           	        *((unsigned char*)&ulWatchDogCnt+1) = EDATA2;
 974   4      				putchar( ' ' );
 975   4                      UartSendByte( EDATA2 );
 976   4                      putchar(' ');
 977   4                      break;
 978   4                  case 2:
 979   4           	        *((unsigned char*)&ulWatchDogCnt+2) = EDATA3;
 980   4      				putchar( ' ' );
 981   4                      UartSendByte( EDATA3 );
 982   4                      putchar(' ');
 983   4                      break;
 984   4                  case 3:
 985   4           	        *((unsigned char*)&ulWatchDogCnt+3) = EDATA4;
 986   4      				putchar( ' ' );
 987   4                      UartSendByte( EDATA4 );
 988   4                      putchar(' ');
 989   4                      break;
 990   4                  default:
 991   4                      break;
 992   4                 }
 993   3      	    }
 994   2          /*
 995   2          #ifdef BUILD_WITH_DEBUG_WD
 996   2      		  XBYTE[A_WD_CTRL]  = 0x03; //погладим собаку и посадим на цепь ЗАГРУЗКА 
 997   2         	      ch = getchar();
 998   2           #endif
 999   2      	 //*/
1000   2      	XBYTE[A_WD_CTRL]  = 0x01; //РАЗРЕШЕНИЕ СЧЁТА 
1001   2          ulWatchDogCnt  += 1;
1002   2      
1003   2      	EADRH = 0;
1004   2      	EADRL = 7;
1005   2          ECON = 1;
1006   2      	EDATA4 = *((unsigned char*)&ulWatchDogCnt+3);
1007   2      	EDATA3 = *((unsigned char*)&ulWatchDogCnt+2);
1008   2      	EDATA2 = *((unsigned char*)&ulWatchDogCnt+1);
1009   2      	EDATA1 = *((unsigned char*)&ulWatchDogCnt);                                          
1010   2      	ECON = 5;
1011   2      	ECON = 2;
1012   2          ECON = 4; 
1013   2        }
1014   1      		// начало автомата по свету
1015   1        while (1)
1016   1        {
1017   2      				filter_status = XBYTE[ FILTER ];
1018   2       	XBYTE[A_WD_CTRL]  = 0x03;
1019   2        	XBYTE[A_WD_CTRL]  = 0x01;
1020   2      	 for( num_ch = 0; num_ch < 3; num_ch++ )
1021   2      	{
1022   3      	//	num_ch = 2;
1023   3      	
1024   3      		if( RI )
1025   3      		{
1026   4      			ch = getchar();
1027   4      			ch = toupper( ch );
1028   4      
1029   4      			if ( ch == 'M') 
1030   4      				{
1031   5                  	    //XBYTE[A_WD_CTRL]  = 0x03; //погладим собаку и посадим на цепь ЗАГРУЗКА 
1032   5      					ADCCON1 = 0xBC;
1033   5      					ADCCON2 = ADCS_EXT_T_SENSE; 
C51 COMPILER V6.12  MAIN                                                                   07/20/2015 16:37:39 PAGE 18  

1034   5      					bDebug = 1;
1035   5      					Debug();			
1036   5      				}
1037   4      			if ( ch == 'S') 
1038   4      				{
1039   5                  	    XBYTE[A_WD_CTRL]  = 0x03; //погладим собаку и посадим на цепь ЗАГРУЗКА 
1040   5      					ADCCON1 = 0xBC;
1041   5      					ADCCON2 = ADCS_EXT_T_SENSE; 
1042   5      					bDebug = 1;
1043   5      					Debug();			
1044   5      				}
1045   4      			if ( ch == 'L') //only auto light
1046   4      				{
1047   5                       	XBYTE[A_WD_CTRL]  = 0x03; //погладим собаку и посадим на цепь ЗАГРУЗКА 
1048   5      					ADCCON1 = 0xBC;
1049   5      					ADCCON2 = ADCS_EXT_T_SENSE; 		
1050   5      				}	
1051   4      			if ( ch == 'T') //only auto temp
1052   4      				{
1053   5                      	XBYTE[A_WD_CTRL]  = 0x03; //погладим собаку и посадим на цепь ЗАГРУЗКА 
1054   5      					bDebug = 1;
1055   5      					Debug();			
1056   5      				}
1057   4      			if (ch == 'Z') 
1058   4      				{
1059   5      					bAverage = 1;
1060   5      				}
1061   4      			if (ch == 'X') 							
1062   4      				{
1063   5      					bAverage = 0;					
1064   5      				}
1065   4      		}
1066   3      
1067   3      
1068   3        
1069   3      		if( bRS485_NEW )
1070   3      		{
1071   4      		  bRS485_NEW = 0;
1072   4      		  puts( s_int_rs485 );
1073   4      		  putchar( '\n' );
1074   4      		  XBYTE[MEM_DEFINE] = MEM_RS485;
1075   4      		  XBYTE[MEM_ADDR] = 0;
1076   4      		  for( j = 0; j < 6; j++ )
1077   4      		     {
1078   5      			  for( n = 0; n < 10; n++ )
1079   5      			     {
1080   6      			     }
1081   5      			  rs_data = XBYTE[MEM_DATA_L];
1082   5      		      UartSendByte( rs_data );
1083   5      			  putchar( ' ' );
1084   5      		     }
1085   4      		  putchar( '\n' );
1086   4      		  UartSendByte( ME_ADDR );
1087   4      		  putchar( ' ' );
1088   4      		  UartSendByte( dsp_state1 );
1089   4      		  putchar( ' ' );
1090   4      		  UartSendByte( dsp_state2 );
1091   4      		  putchar( ' ' );
1092   4      		  UartSendByte( dsp_BVTK1 );
1093   4      		  putchar( ' ' );
1094   4      		  UartSendByte( rs_PSK2 );
1095   4      		  putchar( ' ' );
C51 COMPILER V6.12  MAIN                                                                   07/20/2015 16:37:39 PAGE 19  

1096   4      		  UartSendByte( rs_PSK3 );
1097   4      		}
1098   3      
1099   3      	if( bEXAM )
1100   3      		if( !bSelfExam )
1101   3      		{
1102   4      			bREADY = SelfExamine();
1103   4      			bSelfExam = 1;
1104   4      		}
1105   3      		else   
1106   3      			bSelfExam = 0;
1107   3      
1108   3      	
1109   3      		XBYTE[ NUM_CHANNEL ] = num_ch;
1110   3      
1111   3      		bHistRdy = 0;
1112   3          	status = XBYTE[ HIST_CONTROL ];
1113   3      		if( bHistRdy )
1114   3      	  	{
1115   4      			if( !( bEXT_TV && (VideoMux == num_ch) ) )
1116   4       		    {
1117   5      				bDis_Auto = 0;
1118   5      				putchar( '\n' );
1119   5      				UartSendByte( num_ch );
1120   5      				putchar( ':' );
1121   5      				if (bAverage) 
1122   5      					{CalcHistSum();}
1123   5      				else 
1124   5      					{
1125   6      						CalcAverage();
1126   6      						thres_right = average;
1127   6      					}
1128   5      
1129   5      				// Filtering thres_right histogramm
1130   5      				if(((signed char)( thres_right - (thres_old2[ num_ch ] >> 1 ) - (thres_old1[ num_ch ] >> 1 ))) >=8 )
1131   5      				{
1132   6      					thres_old2[ num_ch ] = thres_old1[ num_ch ];
1133   6      					thres_old1[ num_ch ] = thres_right; // save current value thres_right
1134   6      					thres_right = thres_old2[ num_ch ]; // change current value thres_right to previous value thres_hold
1135   6      				}
1136   5      				else
1137   5      				{
1138   6      					thres_old2[ num_ch ] = thres_old1[ num_ch ];
1139   6      					thres_old1[ num_ch ] = thres_right; // save thres_hold value for next cycle process
1140   6      				}
1141   5      		 		SUM_OF = (unsigned char)( ( *((unsigned short*)((char*)&lsum + 1 )))  );
1142   5      		  		index_tmp = index[ num_ch ]; // reading preaviose index exposition 
1143   5      				printf("  index:= ");
1144   5      				UartSendWord(index_tmp);
1145   5      				printf("  thres:= ");
1146   5      				UartSendWord(thres_right);
1147   5      				printf(" SUM_OF:= ");
1148   5      				UartSendWord(SUM_OF);
1149   5      				printf("    sum:= ");
1150   5      				UartSendWord(sum);
1151   5      				printf("  QUANT:= ");
1152   5      				UartSendWord(QUANT_R);
1153   5      				puts("\n ");
1154   5      				if ((thres_right == 255)&&(bAverage))
1155   5      				{
1156   6      					if (SUM_OF > 30) 
1157   6      					
C51 COMPILER V6.12  MAIN                                                                   07/20/2015 16:37:39 PAGE 20  

1158   6      					new_change = -24;//Achtung 10
1159   6      						else
1160   6      							new_change = -12; //Achtung 10
1161   6      				}
1162   5      				else 
1163   5      					if (bAverage)
1164   5      					{
1165   6      						if (num_ch == 2)
1166   6      							{
1167   7      								if ((thres_right !=255) && (sum == 0xFFFF))
1168   7      								{
1169   8      									//if (SUM_OF > 30) 
1170   8      									//	XBYTE[ FILTER ] = F_IN;
1171   8      									//else 
1172   8      										new_change = -12; //Achtung 10
1173   8      								}
1174   7      								else
1175   7      								{
1176   8      									new_change = change_table[ thres_right ];
1177   8      								}
1178   7      							}
1179   6      						else
1180   6      							{
1181   7      								if ((thres_right !=255) && (sum == 0xFFFF))
1182   7      								{
1183   8      									if (SUM_OF > 30) 
1184   8      										new_change = -24; //Achtung 10
1185   8      									else 
1186   8      										new_change = -12; //Achtung 10
1187   8      								}
1188   7      								else
1189   7      								{
1190   8      									new_change = change_table[ thres_right ];
1191   8      								}
1192   7      							}
1193   6      				   	}
1194   5      					else 
1195   5      					{
1196   6      						new_change = change_table_av[ thres_right ];
1197   6      					}
1198   5      
1199   5      				index_tmp = index_tmp + new_change;
1200   5      				printf("     index:= ");
1201   5      				UartSendWord(index_tmp);
1202   5      				printf(" change:= ");
1203   5      				UartSendWord(new_change);
1204   5      				puts("\n");
1205   5      				index_tmp = index[ num_ch ] + (( index_tmp - index[ num_ch ]) >> 1 );
1206   5      				switch (num_ch) 
1207   5      				{
1208   6      					case 0 : 
1209   6      					{
1210   7      
1211   7      							{
1212   8      								if( index_tmp < 22 ) //change from INDEX_FILT_IN 39 +5
1213   8      								{
1214   9      									filter_status = XBYTE[ FILTER ];
1215   9      									if (!bFILT19_IN) 
1216   9      									{
1217  10      										XBYTE[ FILTER ] = F_IN;
1218  10      										index_tmp = index_tmp;			
1219  10      									}
C51 COMPILER V6.12  MAIN                                                                   07/20/2015 16:37:39 PAGE 21  

1220   9      									else 
1221   9      										index_tmp = index_tmp;			
1222   9      								}
1223   8      								if( index_tmp > 269)//INDEX_FILT_OUT )
1224   8      								{
1225   9      									filter_status = XBYTE[ FILTER ];
1226   9      									if (!bFILT19_OUT) 
1227   9      									{
1228  10      										XBYTE[ FILTER ] = F_OUT;
1229  10      										index_tmp = index_tmp - 154;			
1230  10      									}
1231   9      									else 
1232   9      										index_tmp = index_tmp;			
1233   9      								}
1234   8      							break;
1235   8      							}
1236   7      					}
1237   6      					case 1 : 
1238   6      					{
1239   7      						DUMMY01 = XBYTE[DUMMY_AV01];
1240   7      						if (DUMMY01 > 0x10)
1241   7      						{
1242   8      							XBYTE[ FILTER ] = F_IN;
1243   8      							index_tmp = index_tmp;									
1244   8      							break;
1245   8      						}
1246   7      						else
1247   7      							{
1248   8      								if( index_tmp < INDEX_FILT_IN )
1249   8      								{
1250   9      									filter_status = XBYTE[ FILTER ];
1251   9      									if (!bFILT300_IN) 
1252   9      									{
1253  10      										XBYTE[ FILTER ] = F_IN;
1254  10      										index_tmp = index_tmp;			
1255  10      									}
1256   9      									else 
1257   9      										index_tmp = index_tmp;			
1258   9      								}
1259   8      
1260   8      								if( index_tmp > INDEX_FILT_OUT ) 
1261   8      								{
1262   9      									filter_status = XBYTE[ FILTER ];
1263   9      									if (!bFILT300_OUT) 
1264   9      									{
1265  10      										XBYTE[ FILTER ] = F_OUT;
1266  10      										index_tmp = index_tmp - 134;			
1267  10      									}
1268   9      									else 
1269   9      										index_tmp = index_tmp;			
1270   9      								}
1271   8      							break;
1272   8      							}
1273   7      					}
1274   6      						
1275   6      
1276   6      					case 2 : 
1277   6      					{
1278   7      						
1279   7      						DUMMY02 = XBYTE[DUMMY_AV02];
1280   7      						if (DUMMY02 > 0x10)
1281   7      						{
C51 COMPILER V6.12  MAIN                                                                   07/20/2015 16:37:39 PAGE 22  

1282   8      							XBYTE[ FILTER ] = F_IN;
1283   8      							index_tmp = index_tmp;									
1284   8      							break;
1285   8      						}
1286   7      						else
1287   7      						{
1288   8      							if( index_tmp < 27 )//35
1289   8      							{
1290   9      								filter_status = XBYTE[ FILTER ];
1291   9      								if (!bFILT75_IN) 
1292   9      								{
1293  10      									XBYTE[ FILTER ] = F_IN;
1294  10      									index_tmp = index_tmp;			
1295  10      								}
1296   9      								else index_tmp = index_tmp;			
1297   9      							}
1298   8      							if( index_tmp > INDEX_FILT_OUT )
1299   8      							{
1300   9      								filter_status = XBYTE[ FILTER ];
1301   9      								if (!bFILT75_OUT) 
1302   9      								{
1303  10      									XBYTE[ FILTER ] = F_OUT;
1304  10      									index_tmp = index_tmp - 186;//186			
1305  10      								}
1306   9      								else index_tmp = index_tmp;			
1307   9      							}
1308   8      							break;
1309   8      						}
1310   7      					}
1311   6      
1312   6      			         default:break;
1313   6      
1314   6      				}
1315   5      							printf("   DUMMY02:= ");
1316   5      							UartSendWord(DUMMY02);
1317   5      
1318   5      
1319   5      
1320   5      				if( index_tmp > (signed short)index_max )
1321   5      				{
1322   6      					index_tmp = index_max;
1323   6      				}
1324   5      				else
1325   5      				{
1326   6      					if( index_tmp < 0 )
1327   6      					{
1328   7      						index_tmp = 0;
1329   7      					}
1330   6      				}
1331   5      			   	index[ num_ch ] = index_tmp;
1332   5      
1333   5      		    } 
1334   4      			else
1335   4      				bDis_Auto = 1;
1336   4      			CheckRamReady();
1337   4      			printf("     index:= ");
1338   4      			UartSendWord(index_tmp);
1339   4      			PrintAndSetParam();
1340   4      			XBYTE[ HIST_CONTROL ] = HIST_RDY_CLEAR;
1341   4      		 } 
1342   3      		 XBYTE[ HIST_CONTROL ] = HIST_REQ;
1343   3      		 if( bStep ) 
C51 COMPILER V6.12  MAIN                                                                   07/20/2015 16:37:39 PAGE 23  

1344   3      		 {
1345   4      		 	bDebug = 1;
1346   4      			Debug();
1347   4      		 }
1348   3      
1349   3      	}//for ch 0->2
1350   2      
1351   2        }//while forever
1352   1      
1353   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3632    ----
   CONSTANT SIZE    =     99    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     52      15
   IDATA SIZE       =     50    ----
   BIT SIZE         =      9       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
